%{
	#include "output.hpp"

	using namespace output;

	extern int yylineno;
	int yyerror(const char * message);
    extern int yylex();
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL

%token TRUE
%token FALSE
%token RETURN
%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SWITCH
%token CASE
%token DEFAULT
%token COLON
%token SC
%token COMMA

%token LBRACE
%token RBRACE

%token ID
%token NUM
%token STRING

%right ASSIGN

%left OR
%left AND

%left RELOP_EQ
%nonassoc RELOP_REL

%left BINOP_ADD
%left BINOP_MUL

%right NOT

/* TODO: understand why not left or right */
%nonassoc RPAREN
%nonassoc LPAREN
%nonassoc ELSE

%%

Program     :   Funcs               {}

Funcs       :   FuncDecl Funcs      {}
            |   /* epsilon */       {}

FuncDecl    :   RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE   {}

RetType     :   Type        {}
            |   VOID        {}

Formals     :   FormalsList     {}
            |   /* epsilon */   {}

FormalsList     :   FormalDecl      {}
                |   FormalDecl COMMA FormalsList        {}

FormalDecl      : Type ID    {}

Statements      :   Statement       {}
                |   Statements Statement        {}

Statement       :   LBRACE Statements RBRACE       {}
                |   Type ID SC        {}
                |   Type ID ASSIGN Exp SC        {}
                |   ID ASSIGN Exp SC        {}
                |   Call SC        {}
                |   RETURN SC        {}
                |   RETURN Exp SC        {}
                |   IF LPAREN Exp RPAREN Statement        {printProductionRule(21);}
                |   IF LPAREN Exp RPAREN Statement ELSE Statement        {printProductionRule(22);}
                |   WHILE LPAREN Exp RPAREN Statement        {printProductionRule(23);}
                |   BREAK SC        {printProductionRule(24);}
                |   CONTINUE SC        {printProductionRule(25);}
                |   SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE        {printProductionRule(26);}

Call        :   ID LPAREN ExpList RPAREN       {printProductionRule(27);}
            |   ID LPAREN RPAREN        {printProductionRule(28);}

ExpList     :   Exp     {printProductionRule(29);}
            |   Exp COMMA ExpList       {printProductionRule(30);}

Type        :   INT     {printProductionRule(31);}
            |   BYTE       {}
            |   BOOL       {}

Exp         :   LPAREN Exp RPAREN       {}
            |   Exp BINOP_ADD Exp       {}
            |   Exp BINOP_MUL Exp       {}
            |   ID       {}
            |   Call       {printProductionRule(37);}
            |   NUM       {printProductionRule(38);}
            |   NUM B       {printProductionRule(39);}
            |   STRING       {printProductionRule(40);}
            |   TRUE       {printProductionRule(41);}
            |   FALSE       {printProductionRule(42);}
            |   NOT Exp       {printProductionRule(43);}
            |   Exp AND Exp       {printProductionRule(44);}
            |   Exp OR Exp       {printProductionRule(45);}
            |   Exp RELOP_EQ Exp       {printProductionRule(46);}
            |   Exp RELOP_REL Exp       {printProductionRule(46);}

CaseList         :   CaseDecl CaseList       {printProductionRule(47);}
                 |   CaseDecl       {printProductionRule(48);}
                 |   DEFAULT COLON Statements       {printProductionRule(49);}

CaseDecl        :   CASE NUM COLON Statements       {printProductionRule(50);}

%%

int main() {
	return yyparse();
}

int yyerror(const char* message) {
	errorSyn(yylineno);
	exit(1);
}